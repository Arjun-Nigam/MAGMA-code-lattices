p:=5; /* can be any prime equivalent to -1 mod 6*/
c:=1; /* can be any odd integer */
s:=4; /* must be chosen such that it is a multiple of c, (p+1)s is divisible by 8, and 3(p^c-1)
divides p^s-1. Once we find such an s, all multiples of it will also work */
r:=p^s;
q:=p^c;
k<zeta> := GF(r);
K<t>:=FunctionField(k);
R<y>:=PolynomialRing(GF(r));
E:=EllipticCurve([0,t^q-t]);
h:= function(P) return Maximum(Degree(Denominator(P[1])),Degree(Numerator(P[1]))); end function; 
bil:= function(Q,R) return (h(Q+R)-h(R)-h(Q))/2; end function; 
L:=Roots(y^(6*q-6)+1);
M:=Roots(y^q+y-1);
sumt:=t;
B:=[v[1]: v in M];
A:=[u[1]: u in L];
S:=car<A,B>;
Sol:=[E![x[1]^2*(sumt-(x[2]/x[1]^6))^((q+1) div 3),x[1]^3*(sumt-(x[2]/x[1]^6)^q)^((q+1) div 2)]:
x in S]; /* These are the explicit points of proposition 4.8 */
I:=[Sol[1]];
k:=2;
while k lt #S and #I lt 2*(q-1) do  /* This loop returns a maximal rank sequence of points of Sol */
    x:=Sol[k];
    M := ZeroMatrix(IntegerRing(),#I+1);
    for i in [1..#I] do
        for j in [1..#I] do
            M[i,j]:=bil(I[i],I[j]);
        end for;
    end for;
    for s in [1..#I] do
        M[s,#I+1]:=bil(I[s],x);
    end for;
    for r in [1..#I] do
        M[#I+1,r]:=bil(x,I[r]);
    end for;
    M[#I+1,#I+1]:=bil(x,x);
    if Determinant(M) eq 0 then
        k:=k+1;
    else
        Append(~I,x); 
        k:=k+1;
    end if;
end while;  /* Our next step is to replace I by a Z-linearly independent sequence of points that generates a subgroup bigger than the subgroup generated by I. This will be done by successive iterations of introducing points from Sol and performing the smith-normal form process */
SNFBAS:=[]; 
for i in [1..#I] do
    v:=ZeroMatrix(IntegerRing(),#I+1,1);
    v[i,1]:=1;
    Append(~SNFBAS,v);
end for;
Grm:= function(J) /* returns the Gram matrix of a sequence of points */
    Gr:=ZeroMatrix(RationalField(),#J);
    for i in [1..#J] do
        for j in [1..#J] do
            Gr[i,j]:=bil(J[i],J[j]);
        end for;
    end for;
    return Gr;
end function; 
lincom:= function(Q,J) /* given a basis J and a point Q, the function returns the rational coefficients of Q when written as a linear combination of elements of J */
    CfQ:=ZeroMatrix(RationalField(),#J,1);
    for i in [1..#J] do
        CfQ[i,1]:=bil(Q,J[i]);
    end for;
    return (Grm(J)^(-1))*CfQ;
end function; 
newbasis:= function(Q,J) /* given a basis J and a point Q, this function returns a Z-basis for the subgroup generated by Q and the elements of J*/
    n:=lincom(Q,J);
    U:=[];
    for p in [1..#J] do
        Append(~U,Denominator(n[p,1])); 
    end for;
    d:=LCM(U); 
    if d eq 1 then
        return J;
    else
	    L:=[];
        W := ZeroMatrix(IntegerRing(),#J,#J+1);
        for i in [1..#J] do
            W[i,i]:=d;
        end for;
        for j in [1..#J] do
            W[j,#J+1]:=n[j,1]*d; 
        end for;
        _,_,WSF:=SmithForm(W);
        for j in [1..#J] do
            Append(~L,WSF*SNFBAS[j]);
        end for;   
    	newbas:=[];
    	for i in [1..#J] do
        	vp:=E!0;
		den:=[];
        	for j in [1..#J] do
            		vp:=vp+L[i][j,1]*J[j];
        	end for;
        vp:=vp+L[i][#J+1,1]*Q;
        Append(~newbas,vp);
        end for;
    return newbas;
    end if;
end function;
for i in [1..#Sol] do
    I:=newbasis(Sol[i],I);
end for;
In:=I; 
DetGH:=Numerator(Determinant(Grm(In)));
k:=0;
while((DetGH mod p^k) eq 0) do
    k:=k+1;
end while;
densitylower:=((p^(k-1))^(-0.5))*(((q+1)/12)^(#In div 2));
densitylower;